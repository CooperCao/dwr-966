/*
 * cgitest.c -- CGI Test example for the GoAhead WebServer
 *
 * Copyright (c) GoAhead Software Inc., 1995-2000. All Rights Reserved.
 *
 * See the file "license.txt" for usage and redistribution license requirements
 *
 * $Id: cgitest.c,v 1.2 2001/12/06 16:28:24 bporter Exp $
 */

/******************************** Description *********************************/

/*
 *      Tests the CGI environment variables generated by the GoAhead Webserver
 */

/********************************* Includes ***********************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

#include "../src/config.h"
/******************************************************************************/
/*
 * Compare strings, ignoring case:  normal strcmp return codes.
 *
 *      WARNING: It is not good form to increment or decrement pointers inside a
 *      "call" to tolower et al. These can be MACROS, and have undesired side
 *      effects.
 */

 #define REFRESH_TIMEOUT                "200000"         /* 200000 = 200 secs*/
#define RFC_ERROR "RFC1867 error"

#define MEM_SIZE        1024
#define MEM_HALT        512
int findStrInFile(char *filename, int offset, unsigned char *str, int str_len)
{
        int pos = 0, rc;
        FILE *fp;
        unsigned char mem[MEM_SIZE];

        if(str_len > MEM_HALT)
                return -1;
        if(offset <0)
                return -1;

        fp = fopen(filename, "rb");
        if(!fp)
                return -1;

        rewind(fp);
        fseek(fp, offset + pos, SEEK_SET);
        rc = fread(mem, 1, MEM_SIZE, fp);
        while(rc){
                unsigned char *mem_offset;
                mem_offset = (unsigned char*)memmem(mem, rc, str, str_len);
                if(mem_offset){
                        fclose(fp);     //found it
                        return (mem_offset - mem) + pos + offset;
                }

                if(rc == MEM_SIZE){
                        pos += MEM_HALT;        // 8
                }else
                        break;

                rewind(fp);
                fseek(fp, offset+pos, SEEK_SET);
                rc = fread(mem, 1, MEM_SIZE, fp);
        }

        fclose(fp);
        return -1;
}


void import(char *filename, int offset, int len)
{
    char cmd[4096];
    char data;
    FILE *fp, *src;

    //printf("import start: filename: %s, offset: %d, len:%d  \n",filename,offset,len);
    snprintf(cmd, 4096, "cp %s %s", filename,FW_FILE);
    system(cmd);

    if(!( fp = fopen(FW_FILE, "w+"))){
	  fclose(fp);
      return;
    }

    if(!( src = fopen(filename, "r"))){
      fclose(fp);
      return;
    }

    if( fseek(src, offset, SEEK_SET) == -1){
        printf("fseek error\n");
    }

    while( len > 0){
        if(! fread(&data, 1, 1, src))
            break;
        fwrite(&data, 1, 1, fp);
        len--;
    }

    fclose(fp);
    fclose(src);

	
    char cmd1[1024];
	snprintf(cmd1,sizeof(cmd1),"rm %s",filename);
	system(cmd1);
    //snprintf(cmd1,sizeof(cmd1),"%s %s fullimage 1 saveenv reboot webui &",FW_UP_CMD,FW_FILE);
    //printf("run %s \n",cmd1);
    //snprintf(cmd1,sizeof(cmd1),"cd /tmp && ./ap_fw_upgrade.sh og4610_fw.img");
    //system(cmd1);
}

int strcmpci(char *s1, char *s2)
{
        int             rc;

        if (s1 == NULL || s2 == NULL) {
                return 0;
        }

        if (s1 == s2) {
                return 0;
        }

        do {
                rc = tolower(*s1) - tolower(*s2);
                if (*s1 == '\0') {
                        break;
                }
                s1++;
                s2++;
        } while (rc == 0);

        return rc;
}

/*
 *  ps. callee must free memory...
 */
void *getMemInFile(char *filename, int offset, int len)
{
    void *result;
    FILE *fp;
    if( (fp = fopen(filename, "r")) == NULL ){
        return NULL;
    }
        fseek(fp, offset, SEEK_SET);
    result = malloc(sizeof(unsigned char) * len );
        if(!result)
                return NULL;
    if( fread(result, 1, len, fp) != len){
        free(result);
        return NULL;
    }
    fclose(fp);
    return result;
}

/*************************************************************************/
/*
 *      gogetenv wraps getenv so that (NULL) is returned if the string is
 *      NULL.
 */

char *gogetenv(char *varname)
{
        char *result;

        if ((result = getenv(varname)) == NULL) {
                result = "(NULL)";
        }
        return result;
}

/*************************************************************************/
/*
 *      Convert a two-char hex string into the char it represents
 */

char x2c(char *what)
{
   register char digit;

   digit = (what[0] >= 'A' ? ((what[0] & 0xdf) - 'A') + 10 : (what[0] - '0'));
   digit *= 16;
   digit += (what[1] >= 'A' ? ((what[1] & 0xdf) - 'A') + 10 : (what[1] - '0'));

   return digit;
}

/*************************************************************************/
/*
 *      Reduce any %xx escape sequences to the characters they represent
 */

void unescape_url(char *url)
{
    register int i,j;

    for(i = 0, j = 0; url[j]; ++i,++j) {
        if((url[i] = url[j]) == '%') {
            url[i] = x2c(&url[j + 1]) ;
            j += 2 ;
        }
    }

    url[i] = '\0' ;
}

/*************************************************************************/
/*
 *      getCGIvars()    Routine to read CGI input variables into an
 *                                      array of strings.
 *
 *      Written in 1996 by James Marshall, james@jmarshall.com, except
 *      that the x2c() and unescape_url() routines were lifted directly
 *      from NCSA's sample program util.c, packaged with their HTTPD.
 *
 *      For the latest, see http://www.jmarshall.com/easy/cgi/ .
 *
 *      Read the CGI input and place all name/val pairs into list.
 *      Returns list containing name1, value1, name2, value2, ... , NULL
 */

char **getCGIvars()
{
        register int    i;
        char                    *request_method, *cgiinput, *nvpair, *eqpos;
        int                             content_length, paircount;
    char                        **cgivars, **pairlist;

/*
 *      Depending on the request method, read all CGI input into cgiinput
 *      (really should produce HTML error messages, instead of exit()ing)
 */
    request_method = gogetenv("REQUEST_METHOD") ;

        if (!request_method) {
                request_method = "NOT-CGI";
        }

    if (!strcmp(request_method, "GET") || !strcmp(request_method, "HEAD")) {
        cgiinput= strdup(gogetenv("QUERY_STRING"));
    } else if (!strcmp(request_method, "POST")) {
        if (strcmpci(gogetenv("CONTENT_TYPE"), "application/x-www-form-urlencoded")) {
            printf("getcgivars(): Unsupported Content-Type.\n");
            return NULL;
        }

        if (!(content_length = atoi(gogetenv("CONTENT_LENGTH")))) {
            printf("getcgivars(): No Content-Length was sent with the POST request.\n");
            return NULL;
        }

        if (!(cgiinput = (char *) malloc(content_length + 1))) {
            printf("getcgivars(): Could not malloc for cgiinput.\n") ;
            return NULL;
        }

        if (!fread(cgiinput, content_length, 1, stdin)) {
            printf("Couldn't read CGI input from STDIN.\n");
            return NULL;
        }

        cgiinput[content_length] = '\0' ;
    } else {
        printf("getcgivars(): unsupported REQUEST_METHOD\n") ;
        return NULL;
    }

/*
 *      Change all plusses back to spaces
 */
    for (i = 0; cgiinput[i]; i++) {
                if (cgiinput[i] == '+') {
                        cgiinput[i] = ' ';
                }
        }

/*
 *      First, split on "&" to extract the name-value pairs into pairlist
 */
    pairlist = (char **) malloc(256 * sizeof(char **));
    paircount = 0 ;
    nvpair = strtok(cgiinput, "&");

    while (nvpair) {
        pairlist[paircount++] = strdup(nvpair);
        if (!(paircount % 256)) {
            pairlist= (char **) realloc(pairlist, (paircount + 256)
                                * sizeof(char **));
                }

        nvpair = strtok(NULL, "&") ;
    }

/*
 *      Terminate the pair list with NULL
 */
    pairlist[paircount] = 0;

/*
 *      Then, from the list of pairs, extract the names and values
 */
    cgivars = (char **) malloc((paircount * 2 + 1) * sizeof(char **));
    for (i = 0; i < paircount; i++) {
        if (eqpos = strchr(pairlist[i], '=')) {
            *eqpos = '\0' ;
            unescape_url(cgivars[i * 2 + 1] = strdup(eqpos + 1));
        } else {
            unescape_url(cgivars[i * 2 + 1] = strdup(""));
        }
        unescape_url(cgivars[i * 2] = strdup(pairlist[i]));
    }

/*
 *      Terminate the cgi var list with NULL
 */
    cgivars[paircount * 2] = 0;

/*
 *      Free anything that needs to be freed
 */
    free(cgiinput);

    for (i = 0; pairlist[i]; i++) {
                free(pairlist[i]);
        }

    free(pairlist);

/*
 *      Return the list of name-value strings
 */
    return cgivars;

}

/*************************************************************************/
/*
 *      Test program entry point
 */

int main (int argc, char *argv[])
{
    int file_begin, file_end;
    int line_begin, line_end;
    char err_msg[128];
    char *boundary; int boundary_len;
    char *filename = getenv("UPLOAD_FILENAME");

	char out[128];
	FILE *file;
	int webok=0;

	char cmd[128];
    printf(
"\
Server: %s\n\
Pragma: no-cache\n\
Content-type: text/html\n",
getenv("SERVER_SOFTWARE"));
#if defined(__P02003_Dora)
	printf("\n\
<html>\n\
<head>\n\
<TITLE>D-Link DWR-966</TITLE>\n\
<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\">\n\
</head>\n\
<body>");
#else
	printf("\n\
<html>\n\
<head>\n\
<TITLE>Upload Firmware</TITLE>\n\
<link rel=stylesheet href=/style/normal_ws.css type=text/css>\n\
<meta http-equiv=\"content-type\" content=\"text/html; charset=iso-8859-1\">\n\
</head>\n\
<body onload=\"update()\"> <h1> Upload Firmware</h1>");
#endif
    

      line_begin = 0;
      if((line_end = findStrInFile(filename, line_begin, "\r\n", 2)) == -1){
          printf("%s %d", RFC_ERROR, 1);
          return -1;
      }
      boundary_len = line_end - line_begin;
      boundary = getMemInFile(filename, line_begin, boundary_len);
      //printf("boundary:%s\n", boundary);

      // sth like this..
      // Content-Disposition: form-data; name="filename"; filename="\\192.168.3.171\tftpboot\a.out"
      //
      char *line, *semicolon, *user_filename;
      line_begin = line_end + 2;
      if((line_end = findStrInFile(filename, line_begin, "\r\n", 2)) == -1){
          printf("%s %d", RFC_ERROR, 2);
          goto err;
      }
      line = getMemInFile(filename, line_begin, line_end - line_begin);
      if(strncasecmp(line, "content-disposition: form-data;", strlen("content-disposition: form-data;"))){
          printf("%s %d", RFC_ERROR, 3);
          goto err;
      }
      semicolon = line + strlen("content-disposition: form-data;") + 1;
      if(! (semicolon = strchr(semicolon, ';'))  ){
          printf("We dont support multi-field upload.\n");
          goto err;
      }
      user_filename = semicolon + 2;
      if( strncasecmp(user_filename, "filename=", strlen("filename="))  ){
          printf("%s %d", RFC_ERROR, 4);
          goto err;
      }
      user_filename += strlen("filename=");
      //until now we dont care about what the true filename is.
      free(line);

      // We may check a string  "Content-Type: application/octet-stream" here,
      // but if our firmware extension name is the same with other known ones, 
      // the browser would use other content-type instead.
      // So we dont check Content-type here...
      line_begin = line_end + 2;
      if((line_end = findStrInFile(filename, line_begin, "\r\n", 2)) == -1){
          printf("%s %d", RFC_ERROR, 5);
          goto err;
      }

      line_begin = line_end + 2;
      if((line_end = findStrInFile(filename, line_begin, "\r\n", 2)) == -1){
          printf("%s %d", RFC_ERROR, 6);
          goto err;
      }

      file_begin = line_end + 2;

      if( (file_end = findStrInFile(filename, file_begin, boundary, boundary_len)) == -1){
          printf("%s %d", RFC_ERROR, 7);
          goto err;
      }
      file_end -= 2;		// back 2 chars.(\r\n);

    //printf("file:%s, file_begin:%d, len:%d<br>\n", filename, file_begin, file_end - file_begin);
    //printf("START FIRMWARE UPGRADE <br>");
    //printf("WAITING FOR REBOOT <br>");
    //printf("<script language=\"javascript\">\n");
	system("echo 255 > /tmp/ap_fw_webui");
	
	free(boundary);
	system("echo 2 > /tmp/ap_fw_check");
	system("rm /mnt/data/upfwlog1; cat /proc/meminfo >> /mnt/data/upfwlog1; echo -n [Start to extract image file] >> /mnt/data/upfwlog1 ;date >> /mnt/data/upfwlog1");
	import(filename, file_begin, file_end - file_begin);
#if 1
    //system("echo -n [B] >> /mnt/data/upfwlog;date >> /mnt/data/upfwlog");
	printf("<script language=\"javascript\">\n");
   	printf("window.open(\'%s\',\'_parent\');\n", "../system/fw_upgrade_progress.asp");
    printf("</script>\n");
#else
	//Check result
    file = fopen("/tmp/ap_fw_check", "r");

    if (file)
    {
      while (fgets (out,sizeof(out),file) != NULL)
      {
        fclose(file);
		if (!strncmp(out,"2",1)){		//under checking
		  sleep(1);
		  file = fopen("/tmp/ap_fw_check", "r");
		  continue;
        }else if(!strncmp(out,"1",1)){    //incorrect FW
          printf("Error: Incorrect FW\n");
          break;
        }else if(!strncmp(out,"0",1)){    //PASS
          //Start to upgrade
          printf("<script language=\"javascript\">\n");
          #if defined(__P02003_Dora)
          	printf("window.open(\'%s\',\'_parent\');\n", "../system/fw_upgrade_progress.asp");
          #else
          	printf("window.open(\'%s\',\'_parent\');\n", "../system/progressing_reboot.asp");
          #endif
		  printf("</script>\n");
		  webok=1;
		  //system("echo 0 > /tmp/ap_fw_webui");
          break;
        }else {
          printf("Warning: Please check firmware file.\n");
          break;
        }
	  }
    } 
#endif	
    printf("</body>\n");
    printf("</html>\n");
	//if(webok==1)
	//system("echo 0 > /tmp/ap_fw_webui");
	//system("echo -n [C] >> /mnt/data/upfwlog;date >> /mnt/data/upfwlog");
    return 0;

err:
    printf("</body>\n");
    printf("</html>\n");
    free(boundary);
    exit(-1);
}

/*************************************************************************/
